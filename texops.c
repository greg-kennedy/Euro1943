#include "texops.h"

#include <SDL/SDL.h>
#include <SDL/SDL_image.h>

extern char vol_music;

/**
 * Returns the first power of 2 greater or equal to the specified value.
 *
 * @param value that the  
 *
 *
 */

// FONT
static unsigned char bmp_font[96][8] =
{
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, //U+0020(space)
	{ 0x00, 0x18, 0x00, 0x18, 0x18, 0x3c, 0x3c, 0x18 }, //U+0021(!)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x6c }, //U+0022(")
	{ 0x00, 0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c }, //U+0023(#)
	{ 0x00, 0x30, 0xf8, 0x0c, 0x78, 0xc0, 0x7c, 0x30 }, //U+0024($)
	{ 0x00, 0xc6, 0x66, 0x30, 0x18, 0xcc, 0xc6, 0x00 }, //U+0025(%)
	{ 0x00, 0x76, 0xcc, 0xdc, 0x76, 0x38, 0x6c, 0x38 }, //U+0026(&)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x60, 0x60 }, //U+0027(')
	{ 0x00, 0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18 }, //U+0028(()
	{ 0x00, 0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60 }, //U+0029())
	{ 0x00, 0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00 }, //U+002A(*)
	{ 0x00, 0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00 }, //U+002B(+)
	{ 0x60, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00 }, //U+002C(,)
	{ 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00 }, //U+002D(-)
	{ 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00 }, //U+002E(.)
	{ 0x00, 0x80, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06 }, //U+002F(/)
	{ 0x00, 0x7c, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0x7c }, //U+0030(0)
	{ 0x00, 0xfc, 0x30, 0x30, 0x30, 0x30, 0x70, 0x30 }, //U+0031(1)
	{ 0x00, 0xfc, 0xcc, 0x60, 0x38, 0x0c, 0xcc, 0x78 }, //U+0032(2)
	{ 0x00, 0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78 }, //U+0033(3)
	{ 0x00, 0x1e, 0x0c, 0xfe, 0xcc, 0x6c, 0x3c, 0x1c }, //U+0034(4)
	{ 0x00, 0x78, 0xcc, 0x0c, 0x0c, 0xf8, 0xc0, 0xfc }, //U+0035(5)
	{ 0x00, 0x78, 0xcc, 0xcc, 0xf8, 0xc0, 0x60, 0x38 }, //U+0036(6)
	{ 0x00, 0x30, 0x30, 0x30, 0x18, 0x0c, 0xcc, 0xfc }, //U+0037(7)
	{ 0x00, 0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78 }, //U+0038(8)
	{ 0x00, 0x70, 0x18, 0x0c, 0x7c, 0xcc, 0xcc, 0x78 }, //U+0039(9)
	{ 0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00 }, //U+003A(:)
	{ 0x60, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00 }, //U+003B(//)
	{ 0x00, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18 }, //U+003C(<)
	{ 0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00 }, //U+003D(=)
	{ 0x00, 0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60 }, //U+003E(>)
	{ 0x00, 0x30, 0x00, 0x30, 0x18, 0x0c, 0xcc, 0x78 }, //U+003F(?)
	{ 0x00, 0x78, 0xc0, 0xde, 0xde, 0xde, 0xc6, 0x7c }, //U+0040(@)
	{ 0x00, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x78, 0x30 }, //U+0041(A)
	{ 0x00, 0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc }, //U+0042(B)
	{ 0x00, 0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c }, //U+0043(C)
	{ 0x00, 0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8 }, //U+0044(D)
	{ 0x00, 0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe }, //U+0045(E)
	{ 0x00, 0xf0, 0x60, 0x68, 0x78, 0x68, 0x62, 0xfe }, //U+0046(F)
	{ 0x00, 0x3e, 0x66, 0xce, 0xc0, 0xc0, 0x66, 0x3c }, //U+0047(G)
	{ 0x00, 0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc }, //U+0048(H)
	{ 0x00, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78 }, //U+0049(I)
	{ 0x00, 0x78, 0xcc, 0xcc, 0x0c, 0x0c, 0x0c, 0x1e }, //U+004A(J)
	{ 0x00, 0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6 }, //U+004B(K)
	{ 0x00, 0xfe, 0x66, 0x62, 0x60, 0x60, 0x60, 0xf0 }, //U+004C(L)
	{ 0x00, 0xc6, 0xc6, 0xd6, 0xfe, 0xfe, 0xee, 0xc6 }, //U+004D(M)
	{ 0x00, 0xc6, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0xc6 }, //U+004E(N)
	{ 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38 }, //U+004F(O)
	{ 0x00, 0xf0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xfc }, //U+0050(P)
	{ 0x00, 0x1c, 0x78, 0xdc, 0xcc, 0xcc, 0xcc, 0x78 }, //U+0051(Q)
	{ 0x00, 0xe6, 0x66, 0x6c, 0x7c, 0x66, 0x66, 0xfc }, //U+0052(R)
	{ 0x00, 0x78, 0xcc, 0x1c, 0x70, 0xe0, 0xcc, 0x78 }, //U+0053(S)
	{ 0x00, 0x78, 0x30, 0x30, 0x30, 0x30, 0xb4, 0xfc }, //U+0054(T)
	{ 0x00, 0xfc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc }, //U+0055(U)
	{ 0x00, 0x30, 0x78, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc }, //U+0056(V)
	{ 0x00, 0xc6, 0xee, 0xfe, 0xd6, 0xc6, 0xc6, 0xc6 }, //U+0057(W)
	{ 0x00, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0xc6 }, //U+0058(X)
	{ 0x00, 0x78, 0x30, 0x30, 0x78, 0xcc, 0xcc, 0xcc }, //U+0059(Y)
	{ 0x00, 0xfe, 0x66, 0x32, 0x18, 0x8c, 0xc6, 0xfe }, //U+005A(Z)
	{ 0x00, 0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78 }, //U+005B([)
	{ 0x00, 0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0 }, //U+005C(\)
	{ 0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78 }, //U+005D(])
	{ 0x00, 0x00, 0x00, 0x00, 0xc6, 0x6c, 0x38, 0x10 }, //U+005E(^)
	{ 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, //U+005F(_)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x30 }, //U+0060(`)
	{ 0x00, 0x76, 0xcc, 0x7c, 0x0c, 0x78, 0x00, 0x00 }, //U+0061(a)
	{ 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xe0 }, //U+0062(b)
	{ 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00, 0x00 }, //U+0063(c)
	{ 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x0c, 0x1c }, //U+0064(d)
	{ 0x00, 0x78, 0xc0, 0xfc, 0xcc, 0x78, 0x00, 0x00 }, //U+0065(e)
	{ 0x00, 0xf0, 0x60, 0x60, 0xf0, 0x60, 0x6c, 0x38 }, //U+0066(f)
	{ 0xf8, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00, 0x00 }, //U+0067(g)
	{ 0x00, 0xe6, 0x66, 0x66, 0x76, 0x6c, 0x60, 0xe0 }, //U+0068(h)
	{ 0x00, 0x78, 0x30, 0x30, 0x30, 0x70, 0x00, 0x30 }, //U+0069(i)
	{ 0x78, 0xcc, 0xcc, 0x0c, 0x0c, 0x0c, 0x00, 0x0c }, //U+006A(j)
	{ 0x00, 0xe6, 0x6c, 0x78, 0x6c, 0x66, 0x60, 0xe0 }, //U+006B(k)
	{ 0x00, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x70 }, //U+006C(l)
	{ 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0xcc, 0x00, 0x00 }, //U+006D(m)
	{ 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xf8, 0x00, 0x00 }, //U+006E(n)
	{ 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00, 0x00 }, //U+006F(o)
	{ 0xf0, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00, 0x00 }, //U+0070(p)
	{ 0x1e, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00, 0x00 }, //U+0071(q)
	{ 0x00, 0xf0, 0x60, 0x66, 0x76, 0xdc, 0x00, 0x00 }, //U+0072(r)
	{ 0x00, 0xf8, 0x0c, 0x78, 0xc0, 0x7c, 0x00, 0x00 }, //U+0073(s)
	{ 0x00, 0x18, 0x34, 0x30, 0x30, 0x7c, 0x30, 0x10 }, //U+0074(t)
	{ 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0xcc, 0x00, 0x00 }, //U+0075(u)
	{ 0x00, 0x30, 0x78, 0xcc, 0xcc, 0xcc, 0x00, 0x00 }, //U+0076(v)
	{ 0x00, 0x6c, 0xfe, 0xfe, 0xd6, 0xc6, 0x00, 0x00 }, //U+0077(w)
	{ 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00, 0x00 }, //U+0078(x)
	{ 0xf8, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x00, 0x00 }, //U+0079(y)
	{ 0x00, 0xfc, 0x64, 0x30, 0x98, 0xfc, 0x00, 0x00 }, //U+007A(z)
	{ 0x00, 0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c }, //U+007B()
	{ 0x00, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18 }, //U+007C(|)
	{ 0x00, 0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0 }, //U+007D()
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x76 }, //U+007E(~)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }  //U+007F
};

// Font display list
static GLuint list_font;

///////////////

static int powerOfTwo( int value )
{
	int result = 1 ;
	while ( result < value )
		result *= 2;
	return result ;		
}

// helper function: draw a string anywhere
GLvoid glPrint(GLshort x, GLshort y, const char *text)
{
	glRasterPos2s(x,y);

	glPushAttrib(GL_LIST_BIT);			  // Pushes The Display List Bits	 ( NEW )
	glListBase(list_font - 32);				  // Sets The Base Character to 32	( NEW )
	glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);  // Draws The Display List Text  ( NEW )
	glPopAttrib();					  // Pops The Display List Bits   ( NEW )
}

// Load font
void glFontInit()
{
	unsigned char i;

	// Make one display list for each character.
	list_font = glGenLists(96);
	for (i=0; i < 96; i++)
	{
		glNewList(list_font + i, GL_COMPILE);
			glBitmap(8,8,0,0,8,0,bmp_font[i]);
		glEndList();
	}
}

// Delete font.
void glFontQuit()
{
	glDeleteLists(list_font, 96);
}

// Draws a textured box.
void glBox (int x, int y, int w, int h)
{
	glTexCoord2f(0,0);
	glVertex2i(x, y);
	glTexCoord2f(1,0);
	glVertex2i(x+w, y);
	glTexCoord2f(1,1);
	glVertex2i(x+w, y+h);
	glTexCoord2f(0,1);
	glVertex2i(x, y+h);
}

GLuint load_texture(const char *fname, GLuint min_filt, GLuint max_filt)
{
	int w,h;
	return load_texture_extra(fname,min_filt,max_filt,&w,&h);
}

GLuint load_texture_extra(const char *fname, GLuint min_filt, GLuint max_filt, int *orig_w, int *orig_h)
{
	int w,h;
	GLuint tex = 0;

	SDL_Surface *temp_surf = NULL;
	SDL_Surface *file_surf = IMG_Load(fname);
	if (file_surf == NULL) { printf("Error loading texture '%s': %s\n",fname,IMG_GetError()); return 0; }

	*orig_w = file_surf->w;
	*orig_h = file_surf->h;
	w = powerOfTwo(file_surf->w);
	h = powerOfTwo(file_surf->h);
	if (file_surf->flags & (SDL_SRCALPHA | SDL_SRCCOLORKEY)) {
		// Loaded file has a transparent color?
		temp_surf = SDL_CreateRGBSurface( SDL_SWSURFACE, w, h, 32 /* bits */,
#if SDL_BYTEORDER == SDL_LIL_ENDIAN // OpenGL RGBA masks
				0x000000FF,
				0x0000FF00,
				0x00FF0000,
				0xFF000000
#else
				0xFF000000,
				0x00FF0000,
				0x0000FF00,
				0x000000FF
#endif
				) ;
		if (temp_surf == NULL) { printf("Error creating 32bit surface for '%s': %s\n",fname,SDL_GetError()); free(file_surf); return 0; }
		// clear the dest surface
		SDL_FillRect( temp_surf, 0, SDL_MapRGBA(temp_surf->format,0,0,0,0) ) ;
		SDL_SetAlpha(file_surf,0,0);
		SDL_BlitSurface(file_surf,NULL,temp_surf,NULL);
		SDL_FreeSurface(file_surf);

		glGenTextures( 1, &tex );
		glBindTexture( GL_TEXTURE_2D, tex );

		glTexImage2D(GL_TEXTURE_2D, 0, 4, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, temp_surf->pixels);
		SDL_FreeSurface(temp_surf);
	} else {
		// Loaded file does not have transparent areas.
		temp_surf = SDL_CreateRGBSurface( SDL_SWSURFACE, w, h, 24 /* bits */,
#if SDL_BYTEORDER == SDL_LIL_ENDIAN // OpenGL RGBA masks
				0x000000FF,
				0x0000FF00,
				0x00FF0000,
				0x00000000
#else
				0x00FF0000,
				0x0000FF00,
				0x000000FF,
				0x00000000
#endif
				) ;
		if (temp_surf == NULL) { printf("Error creating 24bit surface for '%s': %s\n",fname,SDL_GetError()); free(file_surf); return 0; }
		SDL_BlitSurface(file_surf,NULL,temp_surf,NULL);
		SDL_FreeSurface(file_surf);

		glGenTextures( 1, &tex );
		glBindTexture( GL_TEXTURE_2D, tex );

		glTexImage2D(GL_TEXTURE_2D, 0, 3, w, h, 0, GL_RGB, GL_UNSIGNED_BYTE, temp_surf->pixels);
		SDL_FreeSurface(temp_surf);
	}

	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP ) ;
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP ) ;

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, min_filt);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, max_filt);

	return tex;
}

//////////////////////////
// music handler functions
Mix_Music *music_play(const char *filename)
{
	// Pointer to new music
	Mix_Music *music = NULL;

	// If volume is non-zero...
	if (vol_music)
	{
		// Attempt to load the music from filename.
		music = Mix_LoadMUS(filename);
		// Check for error
		if (!music)
		{
			fprintf(stderr,"ERROR: music_play: Mix_LoadMUS(\"%s\"): %s\n", filename, Mix_GetError());
		} else {
			// Music loaded OK, play it
			if (Mix_PlayMusic(music, -1))
				fprintf(stderr,"ERROR: music_play: Mix_PlayMusic(\"%s\"): %s\n", filename, Mix_GetError());
		}
	}

	// Return pointer so it can be changed later.
	return music;
}

