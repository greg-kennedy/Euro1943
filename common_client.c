#include "common_client.h"

#include <SDL/SDL_image.h>
#include <string.h>

struct env_t env;

// mouse cursor
static GLuint tex_cursor, list_cursor;

// message bubble
// Static, global values
#define NUM_SPEAKERS 3

// Speech bubble
static GLuint tex_bubble, list_bubble;
static GLuint tex_speaker[NUM_SPEAKERS], list_speaker;

// current state
#define MSG_LINE_LEN 80

static char msg_line[3][MSG_LINE_LEN];
static int msg_speaker;

// FONT
static const unsigned char bmp_font[96][8] =
{
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, //U+0020( )
	{ 0x00, 0x18, 0x00, 0x18, 0x18, 0x3c, 0x3c, 0x18 }, //U+0021(!)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x6c }, //U+0022(")
	{ 0x00, 0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c }, //U+0023(#)
	{ 0x00, 0x30, 0xf8, 0x0c, 0x78, 0xc0, 0x7c, 0x30 }, //U+0024($)
	{ 0x00, 0xc6, 0x66, 0x30, 0x18, 0xcc, 0xc6, 0x00 }, //U+0025(%)
	{ 0x00, 0x76, 0xcc, 0xdc, 0x76, 0x38, 0x6c, 0x38 }, //U+0026(&)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x60, 0x60 }, //U+0027(')
	{ 0x00, 0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18 }, //U+0028(()
	{ 0x00, 0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60 }, //U+0029())
	{ 0x00, 0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00 }, //U+002A(*)
	{ 0x00, 0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00 }, //U+002B(+)
	{ 0x60, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00 }, //U+002C(,)
	{ 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00 }, //U+002D(-)
	{ 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00 }, //U+002E(.)
	{ 0x00, 0x80, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06 }, //U+002F(/)
	{ 0x00, 0x7c, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0x7c }, //U+0030(0)
	{ 0x00, 0xfc, 0x30, 0x30, 0x30, 0x30, 0x70, 0x30 }, //U+0031(1)
	{ 0x00, 0xfc, 0xcc, 0x60, 0x38, 0x0c, 0xcc, 0x78 }, //U+0032(2)
	{ 0x00, 0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78 }, //U+0033(3)
	{ 0x00, 0x1e, 0x0c, 0xfe, 0xcc, 0x6c, 0x3c, 0x1c }, //U+0034(4)
	{ 0x00, 0x78, 0xcc, 0x0c, 0x0c, 0xf8, 0xc0, 0xfc }, //U+0035(5)
	{ 0x00, 0x78, 0xcc, 0xcc, 0xf8, 0xc0, 0x60, 0x38 }, //U+0036(6)
	{ 0x00, 0x30, 0x30, 0x30, 0x18, 0x0c, 0xcc, 0xfc }, //U+0037(7)
	{ 0x00, 0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78 }, //U+0038(8)
	{ 0x00, 0x70, 0x18, 0x0c, 0x7c, 0xcc, 0xcc, 0x78 }, //U+0039(9)
	{ 0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00 }, //U+003A(:)
	{ 0x60, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00 }, //U+003B(/)
	{ 0x00, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18 }, //U+003C(<)
	{ 0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00 }, //U+003D(=)
	{ 0x00, 0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60 }, //U+003E(>)
	{ 0x00, 0x30, 0x00, 0x30, 0x18, 0x0c, 0xcc, 0x78 }, //U+003F(?)
	{ 0x00, 0x78, 0xc0, 0xde, 0xde, 0xde, 0xc6, 0x7c }, //U+0040(@)
	{ 0x00, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x78, 0x30 }, //U+0041(A)
	{ 0x00, 0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc }, //U+0042(B)
	{ 0x00, 0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c }, //U+0043(C)
	{ 0x00, 0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8 }, //U+0044(D)
	{ 0x00, 0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe }, //U+0045(E)
	{ 0x00, 0xf0, 0x60, 0x68, 0x78, 0x68, 0x62, 0xfe }, //U+0046(F)
	{ 0x00, 0x3e, 0x66, 0xce, 0xc0, 0xc0, 0x66, 0x3c }, //U+0047(G)
	{ 0x00, 0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc }, //U+0048(H)
	{ 0x00, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78 }, //U+0049(I)
	{ 0x00, 0x78, 0xcc, 0xcc, 0x0c, 0x0c, 0x0c, 0x1e }, //U+004A(J)
	{ 0x00, 0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6 }, //U+004B(K)
	{ 0x00, 0xfe, 0x66, 0x62, 0x60, 0x60, 0x60, 0xf0 }, //U+004C(L)
	{ 0x00, 0xc6, 0xc6, 0xd6, 0xfe, 0xfe, 0xee, 0xc6 }, //U+004D(M)
	{ 0x00, 0xc6, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0xc6 }, //U+004E(N)
	{ 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38 }, //U+004F(O)
	{ 0x00, 0xf0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xfc }, //U+0050(P)
	{ 0x00, 0x1c, 0x78, 0xdc, 0xcc, 0xcc, 0xcc, 0x78 }, //U+0051(Q)
	{ 0x00, 0xe6, 0x66, 0x6c, 0x7c, 0x66, 0x66, 0xfc }, //U+0052(R)
	{ 0x00, 0x78, 0xcc, 0x1c, 0x70, 0xe0, 0xcc, 0x78 }, //U+0053(S)
	{ 0x00, 0x78, 0x30, 0x30, 0x30, 0x30, 0xb4, 0xfc }, //U+0054(T)
	{ 0x00, 0xfc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc }, //U+0055(U)
	{ 0x00, 0x30, 0x78, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc }, //U+0056(V)
	{ 0x00, 0xc6, 0xee, 0xfe, 0xd6, 0xc6, 0xc6, 0xc6 }, //U+0057(W)
	{ 0x00, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0xc6 }, //U+0058(X)
	{ 0x00, 0x78, 0x30, 0x30, 0x78, 0xcc, 0xcc, 0xcc }, //U+0059(Y)
	{ 0x00, 0xfe, 0x66, 0x32, 0x18, 0x8c, 0xc6, 0xfe }, //U+005A(Z)
	{ 0x00, 0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78 }, //U+005B([)
	{ 0x00, 0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0 }, //U+005C(\)
	{ 0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78 }, //U+005D(])
	{ 0x00, 0x00, 0x00, 0x00, 0xc6, 0x6c, 0x38, 0x10 }, //U+005E(^)
	{ 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, //U+005F(_)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x30 }, //U+0060(`)
	{ 0x00, 0x76, 0xcc, 0x7c, 0x0c, 0x78, 0x00, 0x00 }, //U+0061(a)
	{ 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xe0 }, //U+0062(b)
	{ 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00, 0x00 }, //U+0063(c)
	{ 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x0c, 0x1c }, //U+0064(d)
	{ 0x00, 0x78, 0xc0, 0xfc, 0xcc, 0x78, 0x00, 0x00 }, //U+0065(e)
	{ 0x00, 0xf0, 0x60, 0x60, 0xf0, 0x60, 0x6c, 0x38 }, //U+0066(f)
	{ 0xf8, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00, 0x00 }, //U+0067(g)
	{ 0x00, 0xe6, 0x66, 0x66, 0x76, 0x6c, 0x60, 0xe0 }, //U+0068(h)
	{ 0x00, 0x78, 0x30, 0x30, 0x30, 0x70, 0x00, 0x30 }, //U+0069(i)
	{ 0x78, 0xcc, 0xcc, 0x0c, 0x0c, 0x0c, 0x00, 0x0c }, //U+006A(j)
	{ 0x00, 0xe6, 0x6c, 0x78, 0x6c, 0x66, 0x60, 0xe0 }, //U+006B(k)
	{ 0x00, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x70 }, //U+006C(l)
	{ 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0xcc, 0x00, 0x00 }, //U+006D(m)
	{ 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xf8, 0x00, 0x00 }, //U+006E(n)
	{ 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00, 0x00 }, //U+006F(o)
	{ 0xf0, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00, 0x00 }, //U+0070(p)
	{ 0x1e, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00, 0x00 }, //U+0071(q)
	{ 0x00, 0xf0, 0x60, 0x66, 0x76, 0xdc, 0x00, 0x00 }, //U+0072(r)
	{ 0x00, 0xf8, 0x0c, 0x78, 0xc0, 0x7c, 0x00, 0x00 }, //U+0073(s)
	{ 0x00, 0x18, 0x34, 0x30, 0x30, 0x7c, 0x30, 0x10 }, //U+0074(t)
	{ 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0xcc, 0x00, 0x00 }, //U+0075(u)
	{ 0x00, 0x30, 0x78, 0xcc, 0xcc, 0xcc, 0x00, 0x00 }, //U+0076(v)
	{ 0x00, 0x6c, 0xfe, 0xfe, 0xd6, 0xc6, 0x00, 0x00 }, //U+0077(w)
	{ 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00, 0x00 }, //U+0078(x)
	{ 0xf8, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x00, 0x00 }, //U+0079(y)
	{ 0x00, 0xfc, 0x64, 0x30, 0x98, 0xfc, 0x00, 0x00 }, //U+007A(z)
	{ 0x00, 0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c }, //U+007B({)
	{ 0x00, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18 }, //U+007C(|)
	{ 0x00, 0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0 }, //U+007D(})
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x76 }, //U+007E(~)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }  //U+007F
};

// Font display list
static GLuint list_font;

void init_common() {
	// ///////////////////
	// Load basic (globally shared) resources.
	// Set up mouse cursor: load cursor texture first.
	// Mouse cursor texture
	tex_cursor = load_texture("img/ui/cursor.png", GL_LINEAR, GL_LINEAR);

	// Make a display list for the mouse cursor.
	list_cursor = glGenLists(1);
	glNewList(list_cursor, GL_COMPILE);
	// enable alpha test for simple transparency
	glEnable(GL_ALPHA_TEST);
	glBox(tex_cursor, 32, 32);
	// assume pushmatrix before every cursor draw!
	glPopMatrix();
	glEndList();

	// Load font
	// Make one display list for each character.
	list_font = glGenLists(96);
	for (unsigned char i=0; i < 96; i++)
	{
		glNewList(list_font + i, GL_COMPILE);
			glBitmap(8,8,0,0,8,0,bmp_font[i]);
		glEndList();
	}

	tex_bubble = load_texture("img/hud/bubble.png",GL_NEAREST,GL_NEAREST);

	// Speaker icons
	for (unsigned char i=0; i<NUM_SPEAKERS; i++)
	{
		char buffer[64];
		sprintf(buffer,"img/hud/speakers/%d.png",i);
		tex_speaker[i] = load_texture(buffer,GL_LINEAR, GL_LINEAR);
	}

	// one for the speech bubble
	list_bubble = glGenLists(1);
	glNewList(list_bubble, GL_COMPILE);
		// ENable alpha test: yes to transparency for speech bubble / speaker icon
		glEnable(GL_ALPHA_TEST);
		glBoxPos(tex_bubble, 512, 32, 0, 284);
/*		glBegin(GL_QUADS);
			glBox(144,SCREEN_Y-32,SCREEN_X-288,32);
		glEnd(); */
	glEndList();

	// one for each speaker
	list_speaker = glGenLists(NUM_SPEAKERS);
	for (int i=0; i<NUM_SPEAKERS; i++)
	{
		glNewList(list_speaker + i, GL_COMPILE);
		glBoxPos(tex_speaker[i], 32, 32, -240, 284);
		glEndList();
	}
}

void quit_common()
{
	glDeleteLists(list_speaker, NUM_SPEAKERS);
	glDeleteLists(list_bubble, 1);

	glDeleteTextures( NUM_SPEAKERS, tex_speaker );
	glDeleteTextures( 1, &tex_bubble );

	// Delete font.
	glDeleteLists(list_font, 96);

	glDeleteLists(list_cursor, 1);
	glDeleteTextures(1, &tex_cursor);
}

///////////////

static int powerOfTwo( int value )
{
	int result = 1 ;
	while ( result < value )
		result *= 2;
	return result ;		
}

// helper function: draw a string anywhere
void glPrint(GLshort x, GLshort y, const char *text)
{
	glRasterPos2s(x - 400,y - 300);

	glPushAttrib(GL_LIST_BIT);			  // Pushes The Display List Bits	 ( NEW )
	glListBase(list_font - 32);				  // Sets The Base Character to 32	( NEW )
	glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);  // Draws The Display List Text  ( NEW )
	glPopAttrib();					  // Pops The Display List Bits   ( NEW )
}

void glDrawCursor(const GLfloat x, const GLfloat y)
{
	// TODO: scaled by the actual resolution
	glPushMatrix();
	glTranslatef(x - (SCREEN_X / 2.0), y - (SCREEN_Y / 2.0), 0);
	glCallList(list_cursor);
}

// Draws a textured box of width x height, centered about 0, 0
void glBox(GLuint texture, GLushort w, GLushort h)
{
	glBoxPos(texture, w, h, 0, 0);
}

void glBoxPos(GLuint texture, GLushort w, GLushort h, GLshort x, GLshort y)
{
	glBindTexture(GL_TEXTURE_2D, texture);
	// draw a quad centered around 0,0
	glBegin(GL_QUADS);
		glTexCoord2s(0, 0);
		glVertex2f(x - w/2.0f, y - h/2.0f);
		glTexCoord2s(1, 0);
		glVertex2f(x + w / 2.0f, y - h / 2.0f);
		glTexCoord2s(1, 1);
		glVertex2f(x + w/2.0f, y + h/2.0f);
		glTexCoord2s(0, 1);
		glVertex2f(x - w/2.0f, y + h/2.0f);
	glEnd();
}

// Loads a texture
GLuint load_texture(const char *fname, GLuint min_filt, GLuint max_filt)
{
	return load_texture_extra(fname,min_filt,max_filt,NULL,NULL);
}

// Loads a texture, but returns the texture size in orig_w / orig_h
GLuint load_texture_extra(const char *fname, GLuint min_filt, GLuint max_filt, int *orig_w, int *orig_h)
{
	int w,h;
	GLuint tex = 0;

	SDL_Surface *temp_surf = NULL;
	SDL_Surface *file_surf = IMG_Load(fname);
	if (file_surf == NULL) { printf("Error loading texture '%s': %s\n",fname,IMG_GetError()); return 0; }

	if (orig_w)
		*orig_w = file_surf->w;
	if (orig_h)
		*orig_h = file_surf->h;

	w = powerOfTwo(file_surf->w);
	h = powerOfTwo(file_surf->h);
	if (file_surf->flags & (SDL_SRCALPHA | SDL_SRCCOLORKEY)) {
		// Loaded file has a transparent color?
		temp_surf = SDL_CreateRGBSurface( SDL_SWSURFACE, w, h, 32 /* bits */,
#if SDL_BYTEORDER == SDL_LIL_ENDIAN // OpenGL RGBA masks
				0x000000FF,
				0x0000FF00,
				0x00FF0000,
				0xFF000000
#else
				0xFF000000,
				0x00FF0000,
				0x0000FF00,
				0x000000FF
#endif
				) ;
		if (temp_surf == NULL) { printf("Error creating 32bit surface for '%s': %s\n",fname,SDL_GetError()); free(file_surf); return 0; }
		// clear the dest surface
		SDL_FillRect( temp_surf, 0, SDL_MapRGBA(temp_surf->format,0,0,0,0) ) ;
		SDL_SetAlpha(file_surf,0,0);
		SDL_BlitSurface(file_surf,NULL,temp_surf,NULL);
		SDL_FreeSurface(file_surf);

		glGenTextures( 1, &tex );
		glBindTexture( GL_TEXTURE_2D, tex );

		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, temp_surf->pixels);
		SDL_FreeSurface(temp_surf);
	} else {
		// Loaded file does not have transparent areas.
		temp_surf = SDL_CreateRGBSurface( SDL_SWSURFACE, w, h, 24 /* bits */,
#if SDL_BYTEORDER == SDL_LIL_ENDIAN // OpenGL RGBA masks
				0x000000FF,
				0x0000FF00,
				0x00FF0000,
				0x00000000
#else
				0x00FF0000,
				0x0000FF00,
				0x000000FF,
				0x00000000
#endif
				) ;
		if (temp_surf == NULL) { printf("Error creating 24bit surface for '%s': %s\n",fname,SDL_GetError()); free(file_surf); return 0; }
		SDL_BlitSurface(file_surf,NULL,temp_surf,NULL);
		SDL_FreeSurface(file_surf);

		glGenTextures( 1, &tex );
		glBindTexture( GL_TEXTURE_2D, tex );

		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, w, h, 0, GL_RGB, GL_UNSIGNED_BYTE, temp_surf->pixels);
		SDL_FreeSurface(temp_surf);
	}

	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP ) ;
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP ) ;

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, min_filt);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, max_filt);

	return tex;
}

void message_clear()
{
	msg_speaker = -1;
	memset(msg_line,'\0',MSG_LINE_LEN*3);
}

void message_post(int speaker, const char *message)
{
	memcpy(msg_line[2],msg_line[1],MSG_LINE_LEN);
	memcpy(msg_line[1],msg_line[0],MSG_LINE_LEN);
	memcpy(msg_line[0],message,MSG_LINE_LEN);
	msg_speaker = speaker;
}

void message_draw()
{
	glCallList(list_bubble);
	// if there is a speaker...
	if (msg_speaker >= 0)
		glCallList(list_speaker);

	glDisable(GL_ALPHA_TEST);
	glDisable(GL_TEXTURE_2D);

	// draw both lines.
	glColor3f(0,0,0);
	glPrint(200,SCREEN_Y-5,msg_line[0]);
	glPrint(200,SCREEN_Y-13,msg_line[1]);
	glPrint(200,SCREEN_Y-21,msg_line[2]);
	glColor3f(1,1,1);
	glEnable(GL_TEXTURE_2D);
}

//////////////////////////
// music handler functions
Mix_Music *music_play(const char *filename)
{
	// Pointer to new music
	Mix_Music *music = NULL;

	// If volume is non-zero...
	if (env.ok_music && env.volume)
	{
		// Attempt to load the music from filename.
		music = Mix_LoadMUS(filename);
		// Check for error
		if (!music)
		{
			fprintf(stderr,"ERROR: music_play: Mix_LoadMUS(\"%s\"): %s\n", filename, Mix_GetError());
		} else {
			// Music loaded OK, play it
			if (Mix_PlayMusic(music, -1))
				fprintf(stderr,"ERROR: music_play: Mix_PlayMusic(\"%s\"): %s\n", filename, Mix_GetError());
		}
	}

	// Return pointer so it can be changed later.
	return music;
}

